# Scene Policy 구현 작업지시서

> **상태:** 미실행
> **담당:** Agent A (LLM mood 분류 + scene_director) → Agent B (layout 추가 + renderer 반영)
> **크로스 도메인:** Agent A↔B 간 scene 계약 변경 포함 — Team Lead 조율 필요
> **선행 조건:** 없음 (기존 코드에 추가하는 신규 기능)

---

## 목적

WaggleBot이 만드는 쇼츠 영상의 **화면 구성을 정형화**한다.

현재 문제: 커뮤니티 글의 형태가 매우 다양함에도 화면 구성 규칙이 없어 결과물이 매번 달라진다.
- 이미지 0장 + 텍스트만 길게 있는 글
- 이미지 3장 + 텍스트 100자인 글
- 이미지 10장 + 텍스트 20자인 글

해결: **감정(mood) 기반 프리셋**으로 인트로/본문/아웃트로 화면 구성을 정책(Policy)으로 정의하고, `config/scene_policy.json` 한 파일로 중앙 관리한다. 코드를 수정하지 않고 JSON만 바꾸면 연출이 바뀌는 구조.

---

## 1. 감정(Mood) 프리셋 — 9가지

LLM이 글의 분위기를 분석하여 9가지 중 하나로 분류한다.

| mood 키 | 한글명 | 설명 | 대표 커뮤니티 글 유형 |
|---|---|---|---|
| `touching` | 감동 | 훈훈한 미담, 가족 이야기, 눈물 나는 사연 | "택시기사 아저씨가..." |
| `humor` | 유머 | 웃긴 썰, 밈, 어이없는 실수담 | "오늘 회사에서 ㅋㅋㅋ" |
| `anger` | 분노 | 진상, 빌런 참교육, 억울한 사연 | "옆집 층간소음 진짜..." |
| `sadness` | 슬픔 | 이별, 실패, 안타까운 소식 | "반려동물이 무지개다리를..." |
| `horror` | 공포 | 무서운 이야기, 기묘한 경험, 소름 | "군대에서 불침번 서는데..." |
| `info` | 정보 | 생활 꿀팁, 지식, 리뷰 | "자취생 필수 앱 추천" |
| `controversy` | 논란 | 찬반 갈리는 주제, 뜨거운 감자 | "깻잎 논쟁 어떻게 생각함?" |
| `daily` | 일상 | 평범한 공감 이야기 | "출근길 지하철에서..." |
| `shock` | 충격 | 상상 초월 기행, 황당무계한 사건 | "친구가 갑자기 벌레를..." |

### mood가 결정하는 3가지

| # | 영역 | 설명 | 소스 경로 | 선택 방식 |
|---|---|---|---|---|
| 1 | **이미지** | 인트로/아웃트로 배경 이미지 | `assets/image/{intro\|outro}/mood/{mood_key}/` | **폴더 내 랜덤** |
| 2 | **BGM** | 영상 배경음악 | `assets/bgm/mood/{mood_key}/` | **폴더 내 랜덤** |
| 3 | **TTS 감정** | 읽어줄 때 감정 톤 | scene_policy.json `tts_emotion` | 그대로 전달 |

> **자막은 mood와 무관.** 맑은고딕 고정. mood별로 바뀌지 않는다.

---

## 2. config/scene_policy.json 설계

### 파일 위치

`config/scene_policy.json` — 새로 생성.

> **소유권:** Agent A(scene_director) 도메인에 귀속.

### 핵심 설계: 폴더 기반 랜덤 선택

단일 파일 경로가 아닌 **폴더 경로**를 지정한다. 런타임에 해당 폴더 내 파일 중 하나를 랜덤으로 선택한다. 폴더에 파일을 추가하기만 하면 자동으로 후보에 포함된다.

### JSON 구조

```json
{
  "_version": "2.0",
  "_description": "WaggleBot 쇼츠 화면 구성 정책. 이 파일만 수정하면 연출이 바뀐다. 모든 에셋은 폴더 단위로 관리하며 런타임에 랜덤 선택.",

  "moods": {
    "touching": {
      "label": "감동",
      "intro_image_dir": "assets/image/intro/mood/touching",
      "outro_image_dir": "assets/image/outro/mood/touching",
      "bgm_dir": "assets/bgm/mood/touching",
      "tts_emotion": "gentle"
    },
    
    (생략)
    
    "shock": {
      "label": "충격",
      "intro_image_dir": "assets/image/intro/mood/shock",
      "outro_image_dir": "assets/image/outro/mood/shock",
      "bgm_dir": "assets/bgm/mood/shock",
      "tts_emotion": "surprised"
    }
  },

  "scene_rules": {
    "intro": {
      "description": "제목을 읽어주는 첫 화면",
      "with_image": {
        "layout": "img_text",
        "image_source": "post_images[0]",
        "note": "글에 이미지가 1장 이상이면 첫 번째 이미지 사용"
      },
      "without_image": {
        "layout": "img_only",
        "image_source": "intro_image_dir",
        "note": "글에 이미지가 0장이면 mood별 인트로 폴더에서 랜덤 선택"
      }
    },
    "body": {
      "description": "본문을 읽는 화면들",
      "with_image": { "layout": "img_text" },
      "without_image": { "layout": "text_only" },
      "image_distribution": "even_spread",
      "image_distribution_note": "공식: interval = total_lines / (remaining_images + 1)"
    },
    "outro": {
      "description": "마지막 화면 — 고정 멘트 + mood별 아웃트로 폴더에서 랜덤 이미지",
      "layout": "img_only",
      "image_source": "outro_image_dir",
      "fixed_texts": [
        "여러분들의 생각은 어떤가요?",
        "여러분들의 생각을 댓글로 남겨주세요!",
        "이 이야기, 어떻게 생각하시나요?"
      ],
      "fixed_text_selection": "random"
    }
  },

  "defaults": {
    "fallback_mood": "daily",
    "max_body_images": 8,
    "min_body_lines_per_image": 2,
    "supported_image_ext": [".png", ".jpg", ".jpeg", ".webp"],
    "supported_bgm_ext": [".mp3", ".wav", ".ogg"]
  }
}
```

### 폴더 내 랜덤 선택 유틸 함수

```python
import random
from pathlib import Path

def pick_random_file(dir_path: str, extensions: list[str]) -> Path | None:
    """지정 폴더에서 지원 확장자의 파일 하나를 랜덤 선택. 비어있으면 None."""
    folder = Path(dir_path)
    if not folder.is_dir():
        return None
    files = [f for f in folder.iterdir() if f.suffix.lower() in extensions]
    return random.choice(files) if files else None
```

---

## 3. layout.json 수정 — `img_only` 레이아웃 추가

**담당: Agent B** (renderer 도메인)

현재 `config/layout.json`에 `img_text`와 `text_only`는 존재.
`img_only`를 추가해야 인트로(이미지 없는 글)와 아웃트로에서 사용 가능.

```json
{
  "img_only": {
    "description": "텍스트 없이 이미지만 전체 화면으로 표시",
    "image_area": {
      "x": 90,
      "y": 550,
      "width": 900,
      "height": 900,
      "fit_mode": "cover",
      "border_radius": 20
    }
  }
}
```

> `img_text`에서 `text_area`를 제거한 형태.

---

## 4. 본문 이미지 균등 분배 알고리즘

### 공식

```
interval = total_text_lines / (remaining_images + 1)
```

### 시나리오별 동작

```
Case 1: 텍스트 10줄, 남은 이미지 1장
  interval = 10 / 2 = 5 → 5번째 줄에 이미지
  결과: [text×5] → [img_text] → [text×4]

Case 2: 텍스트 10줄, 남은 이미지 3장
  interval = 10 / 4 = 2.5 → 3번째, 5번째, 8번째 줄에 이미지
  결과: [text×2] → [img_text] → [text×2] → [img_text] → [text×2] → [img_text] → [text×1]

Case 3: 텍스트 10줄, 남은 이미지 10장+
  → 매 줄 img_text. 넘치는 이미지는 max_body_images로 제한

Case 4: 텍스트 3줄, 남은 이미지 0장
  → 전부 text_only

Case 5: 텍스트 0줄 (이미지만 있는 글)
  → img_only 순차 나열. max_body_images까지
```

### 의사 코드

```python
def distribute_images(text_lines: list[str], images: list[Path], max_images: int) -> list[Scene]:
    """본문 텍스트 라인에 이미지를 균등 분배하여 Scene 리스트 생성"""
    remaining_imgs = images[:max_images]

    # Case 5: 텍스트 없이 이미지만
    if not text_lines and remaining_imgs:
        return [Scene(layout="img_only", image=img) for img in remaining_imgs]

    # Case 4: 이미지 없음
    if not remaining_imgs:
        return [Scene(layout="text_only", text=line) for line in text_lines]

    total = len(text_lines)
    n_imgs = len(remaining_imgs)

    # Case 3: 이미지 ≥ 텍스트
    if n_imgs >= total:
        return [Scene(layout="img_text", text=line, image=remaining_imgs[i] if i < n_imgs else None)
                for i, line in enumerate(text_lines)]

    # Case 1, 2: 균등 분배
    interval = total / (n_imgs + 1)
    img_positions = {round(interval * (i + 1)) - 1 for i in range(n_imgs)}
    img_idx = 0
    scenes = []

    for line_idx, line in enumerate(text_lines):
        if line_idx in img_positions and img_idx < n_imgs:
            scenes.append(Scene(layout="img_text", text=line, image=remaining_imgs[img_idx]))
            img_idx += 1
        else:
            scenes.append(Scene(layout="text_only", text=line))
    return scenes
```

---

## 5. LLM mood 분류 — 프롬프트 수정

**담당: Agent A** (`ai_worker/llm/client.py`)

`generate_script()` 프롬프트에 mood 분류 지시를 추가. ScriptData에 `mood` 필드 추가.

### LLM 프롬프트 추가 내용

```
아래 글의 분위기를 다음 9가지 중 정확히 하나로 분류하세요:
touching(감동), humor(유머), anger(분노), sadness(슬픔), horror(공포),
info(정보), controversy(논란), daily(일상), shock(충격)

9가지 분위기정보는 나중에 추가, 삭제가 될수 있다.
전역적으로 사용해서 TTS, 레이아웃, 씬 등 여러 기능에서 사용할 수 있어야 한다.

JSON 응답에 "mood" 필드를 포함하세요.
```

### ScriptData 변경

> ⚠️ `db/models.py`의 ScriptData 수정 필요 — **CEO 승인 대상 (Proposal)**

```python
@dataclass
class ScriptData:
    hook: str
    body: list[str]
    closer: str
    mood: str = "daily"  # 신규 필드, 기본값 daily (fallback)
```

기존 데이터는 mood 필드가 없어도 기본값 "daily"로 처리됨 → **하위 호환성 유지**.

---

## 6. scene_director 수정 — Policy 기반 Scene 구성

**담당: Agent A** (`ai_worker/pipeline/scene_director.py`)

### 파이프라인 흐름

```
1. ScriptData에서 mood 읽기 (없으면 defaults.fallback_mood 사용)

2. scene_policy.json 로드 → moods[mood] 프리셋 취득
   - intro_image_dir  (폴더 경로)
   - outro_image_dir  (폴더 경로)
   - bgm_dir          (폴더 경로)
   - tts_emotion      (TTS 감정 키)

3. 크롤링된 이미지 목록 확인 (Post에 첨부된 원본 이미지)

4. 인트로 Scene
   - 이미지 ≥ 1장: layout="img_text", image=post_images[0], text=hook
   - 이미지 = 0장: layout="img_only", image=pick_random_file(intro_image_dir)

5. 본문 Scene
   - 남은 이미지 = post_images[1:] (인트로에서 1장 사용한 경우)
   - 이미지 0장인 글이면 post_images 전체가 남음 (인트로에서 프리셋 사용)
   - distribute_images(body_lines, remaining_imgs, max_body_images) 호출

6. 아웃트로 Scene
   - layout="img_only", image=pick_random_file(outro_image_dir)
   - tts_text = fixed_texts에서 랜덤 선택

7. BGM 선택
   - pick_random_file(bgm_dir) → 폴더 내 음원 랜덤

8. TTS 감정 적용
   - tts_emotion 값을 모든 Scene의 TTS에 전달
```

---

## 7. TTS 감정 톤 — mood별 매핑

**담당: Agent A** (`ai_worker/tts/`)

TTS 엔진이 텍스트를 읽을 때 mood에 맞는 감정을 넣어 읽는다.
**자막은 맑은고딕으로 고정이며 mood와 무관.**

| mood | tts_emotion | 설명 |
|---|---|---|
| `touching` | `gentle` | 따뜻하고 부드러운 톤 |
| `humor` | `cheerful` | 밝고 활기찬 톤 |
| `anger` | `serious` | 단호하고 진지한 톤 |
| `sadness` | `sad` | 차분하고 낮은 톤 |
| `horror` | `whispering` | 속삭이는 듯한 톤 |
| `info` | `neutral` | 뉴스 앵커 같은 중립 톤 |
| `controversy` | `serious` | 진지한 토론 톤 |
| `daily` | `friendly` | 친근한 대화 톤 |
| `shock` | `surprised` | 놀란 듯한 톤 |

### 구현

Scene에 tts_emotion 포함하여 전달. `ai_worker/tts/base.py`에 emotion 파라미터 인터페이스 추가. 엔진이 감정을 지원하지 않으면 무시 (graceful degradation).

---

## 8. Scene 인터페이스 계약 변경

> ⚠️ Agent A → Agent B 계약 변경 — `.claude/contracts/scene_interface.md` 업데이트 필요

| 필드 | 타입 | 설명 | 변경 |
|---|---|---|---|
| `layout_key` | str | `"img_only"` 값 추가 | **변경** |
| `mood` | str | 9가지 감정 키 | **신규** |
| `tts_emotion` | str | TTS 감정 톤 키 | **신규** |
| `bgm_path` | Path | 선택된 BGM 파일 경로 (폴더에서 랜덤 선택된 결과) | **신규** |

> 자막 관련 필드 변경 없음 (맑은고딕 고정).

---

## 9. 에셋 준비

### 디렉토리 구조

```
assets/
├── image/
│   ├── intro/
│   │   └── mood/
│   │       ├── touching/    ← 이미지 3장 이상
│   │       ├── humor/
│   │       ├── anger/
│   │       ├── sadness/
│   │       ├── horror/
│   │       ├── info/
│   │       ├── controversy/
│   │       ├── daily/
│   │       └── shock/
│   └── outro/
│       └── mood/
│           ├── touching/    ← 이미지 3장 이상
│           ├── humor/
│           ├── anger/
│           ├── sadness/
│           ├── horror/
│           ├── info/
│           ├── controversy/
│           ├── daily/
│           └── shock/
└── bgm/
    └── mood/
        ├── touching/        ← BGM 2곡 이상 (60초 초과)
        ├── humor/
        ├── anger/
        ├── sadness/
        ├── horror/
        ├── info/
        ├── controversy/
        ├── daily/
        └── shock/
```

### 에셋 수집 기준

**이미지 (9 mood × 2종(intro/outro) × 3장 = 54장):**
- 무료 스톡 이미지 (Unsplash, Pexels, Pixabay 등)에서 mood 키워드로 검색
- 해상도: 1080×1920 (쇼츠 세로) 권장. 다른 비율은 renderer가 cover로 처리
- 포맷: PNG, JPG, WEBP

| mood | 이미지 검색 키워드 예시 |
|---|---|
| touching | warm sunset, family hug, heartwarming |
| humor | funny face, comedy, laughing people |
| anger | fire, storm, intense red |
| sadness | rain window, lonely bench, blue tone |
| horror | dark forest, fog, creepy atmosphere |
| info | lightbulb, books, clean workspace |
| controversy | debate, balance scale, versus |
| daily | coffee morning, subway, casual life |
| shock | surprised expression, explosion, lightning |

**BGM (9 mood × 2곡 = 18곡):**
- 유튜브 쇼츠에서 저작권 문제 없이 사용 가능한 무료 음원
- 소스: YouTube Audio Library, Pixabay Music
- 길이: **60초 초과 필수** (쇼츠 최대 길이 커버)
- 포맷: MP3, WAV, OGG

| mood | BGM 검색 키워드 예시 |
|---|---|
| touching | emotional piano, heartwarming orchestral |
| humor | upbeat ukulele, fun whistle |
| anger | intense drums, dark hip-hop beat |
| sadness | sad piano, melancholic strings |
| horror | suspense ambient, creepy drone |
| info | corporate background, light acoustic |
| controversy | tense documentary, debate underscore |
| daily | lo-fi chill, casual acoustic |
| shock | dramatic hit, cinematic tension |

### fallback 체인 (에셋 폴더가 비어있을 때)

```
1. 해당 mood 폴더에서 랜덤 선택 시도
2. 실패 → defaults.fallback_mood("daily") 폴더에서 시도
3. 실패 → 단색 배경 자동 생성 (이미지) / 무음 (BGM)
```

---

## 10. 구현 순서

### Phase 1: 기반 (순차)

| 순서 | Agent | 작업 | 파일 |
|---|---|---|---|
| 1-1 | CEO | ScriptData에 mood 필드 추가 Proposal 승인 | `db/models.py` |
| 1-2 | Agent A | `config/scene_policy.json` 생성 (Section 2 JSON) | `config/scene_policy.json` |
| 1-3 | Agent A | 에셋 디렉토리 구조 생성 (빈 폴더 27개) | `assets/image/`, `assets/bgm/` |
| 1-4 | Agent B | `config/layout.json`에 img_only 추가 | `config/layout.json` |

### Phase 2: 에셋 수집

| 순서 | 작업 | 결과 |
|---|---|---|
| 2-1 | 인트로 이미지 수집 — 9 mood × 3장 (무료 스톡 크롤링) | `assets/image/intro/mood/{mood}/` 각 3장 |
| 2-2 | 아웃트로 이미지 수집 — 9 mood × 3장 (무료 스톡 크롤링) | `assets/image/outro/mood/{mood}/` 각 3장 |
| 2-3 | BGM 수집 — 9 mood × 2곡 (유튜브/Pixabay 무료 음원, 60초+) | `assets/bgm/mood/{mood}/` 각 2곡 |

### Phase 3: 코어 로직 (Agent A)

| 순서 | 작업 | 파일 |
|---|---|---|
| 3-1 | `pick_random_file()` 유틸 구현 | `ai_worker/pipeline/scene_director.py` |
| 3-2 | `generate_script()` 프롬프트에 mood 분류 추가 | `ai_worker/llm/client.py` |
| 3-3 | `distribute_images()` 균등 분배 함수 구현 | `ai_worker/pipeline/scene_director.py` |
| 3-4 | `SceneDirector.direct()` policy 기반 리팩토링 | `ai_worker/pipeline/scene_director.py` |

### Phase 4: 렌더링 연동 (Agent B)

| 순서 | 작업 | 파일 |
|---|---|---|
| 4-1 | img_only 레이아웃 렌더링 구현 | `ai_worker/renderer/layout.py` |
| 4-2 | Scene.bgm_path → BGM 믹싱 반영 | `ai_worker/renderer/video.py` |

### Phase 5: TTS 감정 연동 (Agent A)

| 순서 | 작업 | 파일 |
|---|---|---|
| 5-1 | `ai_worker/tts/base.py`에 emotion 파라미터 인터페이스 추가 | `ai_worker/tts/base.py` |
| 5-2 | Fish Speech 등 지원 엔진에 감정 파라미터 연동 | `ai_worker/tts/fish_client.py` 등 |
| 5-3 | 미지원 엔진 graceful degradation | 기타 TTS 파일 |

### 검증

```bash
# 1. 에셋 디렉토리 검증
python -c "
from pathlib import Path
moods = ['touching','humor','anger','sadness','horror','info','controversy','daily','shock']
for m in moods:
    intro = list(Path(f'assets/image/intro/mood/{m}').glob('*'))
    outro = list(Path(f'assets/image/outro/mood/{m}').glob('*'))
    bgm = list(Path(f'assets/bgm/mood/{m}').glob('*'))
    s = '✅' if intro and outro and bgm else '❌'
    print(f'{s} {m}: intro={len(intro)} outro={len(outro)} bgm={len(bgm)}')
"

# 2. Policy JSON 검증
python -c "
import json
with open('config/scene_policy.json') as f:
    p = json.load(f)
assert len(p['moods']) == 9
for m in p['moods'].values():
    assert 'intro_image_dir' in m
    assert 'bgm_dir' in m
    assert 'tts_emotion' in m
print('scene_policy.json OK')
"

# 3. ScriptData mood 검증
python -c "
from db.models import ScriptData
sd = ScriptData(hook='test', body=['line1'], closer='end')
assert sd.mood == 'daily'
print('ScriptData OK')
"

# 4. pick_random_file 검증
python -c "
from ai_worker.pipeline.scene_director import pick_random_file
r = pick_random_file('assets/image/intro/mood/daily', ['.png','.jpg','.jpeg','.webp'])
print(f'Random: {r}')
"
```

---

## 11. 주의사항

### 하위 호환성
- 기존 mood 없는 ScriptData → `mood="daily"` 자동 처리
- scene_policy.json 없으면 기존 로직 유지 (fallback)
- 에셋 폴더 비어있으면 fallback 체인 적용 (Section 9 참조)

### 자막 — 변경 없음
- 맑은고딕 고정. mood와 무관. 이번 작업에서 자막 관련 코드 수정하지 않음.

### VRAM 영향 없음
- Scene 구성 단계만 변경. FFmpeg/GPU 패턴 불변.

### 향후 확장
- mood 추가: scene_policy.json에 항목 + 에셋 폴더 생성만으로 가능
- 에셋 추가: 폴더에 파일 넣기만 하면 자동 후보 포함
- 아웃트로 멘트 추가: fixed_texts 배열에 추가
- mood별 자막 컬러: scene_policy.json에 `subtitle_color` 필드 추가 가능
