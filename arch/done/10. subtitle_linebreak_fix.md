# 자막 줄바꿈 버그 수정 지시서

> **상태:** 완료 (2026-02-27)
> **심각도:** 높음 — 모든 영상의 자막 품질에 영향
> **담당:** Agent A (scene_director) + Agent B (renderer)

---

## 증상

편집실에서 의도적으로 줄을 나눈 텍스트가 렌더링 시 **합쳐진 후 글자 수 기준으로 재분할**되어 부자연스러운 줄바꿈이 발생한다.

### 재현 데이터

DB에 저장된 ScriptData JSON:

```json
{
  "hook": "쿠팡이 베이비밀크 판매가격을 올렸나?",
  "body": [
    {"type": "body", "line_count": 2, "lines": ["저체중", "영유아용 특수 분유에 대해"]},
    {"type": "body", "line_count": 1, "lines": ["정가는 4만 원이래"]},
    {"type": "body", "line_count": 2, "lines": ["쿠팡은 이 가격에 팔다가", "수입사 남은 재고 물량을 아도 침"]},
    {"type": "body", "line_count": 1, "lines": ["그리곤 가격을 높여 판매했음"]},
    {"type": "body", "line_count": 1, "lines": ["참 미국 기업 대단해"]},
    {"type": "comment", "author": "연이들아빠", "line_count": 2, "lines": ["2찍이", "뒤져야 나라가 산다"]},
    {"type": "comment", "author": "PAV", "line_count": 1, "lines": ["매점매석 씨바꺼공정이 좆팡 가즈아"]},
    {"type": "comment", "author": "싱아풀", "line_count": 1, "lines": ["네이버랑 비교하면 전혀 싼게 아님"]}
  ],
  "closer": "여러분들의 생각은 어떤가요?"
}
```

### 기대 vs 실제

| # | 원본 lines 배열 | 기대 출력 | 실제 출력 | 원인 |
|---|---|---|---|---|
| 1 | `["쿠팡이 베이비밀크 판매가격을 올렸나?"]` (hook, 단일 문자열) | `쿠팡이 베이비밀크`<br>`판매가격을 올렸나?` | `쿠팡이 베이비밀크 판매가격을`<br>`올렸나?` | 15자 하드컷 |
| 2 | `["저체중", "영유아용 특수 분유에 대해"]` | `저체중`<br>`영유아용 특수 분유에 대해` | `저체중 영유아용 특수분유에 대`<br>`해` | lines 합쳐짐 + 16자 하드컷 |
| 3 | `["쿠팡은 이 가격에 팔다가", "수입사 남은 재고 물량을 아도 침"]` | `쿠팡은 이 가격에 팔다가`<br>`수입사 남은 재고 물량을 아도 침` | `쿠팡은 이 가격에 팔다가 수입사`<br>`남은 재고 물량을 아도 침` | lines 합쳐짐 + 하드컷 |
| 4 | `["매점매석 씨바꺼공정이 좆팡 가즈아"]` (단일) | `매점매석 씨바꺼공정이`<br>`좆팡 가즈아` | `매점매석 씨바꺼공정이 좆팡 가`<br>`즈아` | 공백 무시 하드컷 |

---

## 근본 원인 분석

파이프라인의 어딘가에서 다음 두 가지가 발생하고 있다:

### 버그 1: lines 배열 합치기 (join)

`lines: ["저체중", "영유아용 특수 분유에 대해"]`가 렌더링 전에
`"저체중 영유아용 특수 분유에 대해"`로 합쳐지고 있다.

편집실에서 사용자가 의도적으로 나눈 줄바꿈이 무시되는 것.

### 버그 2: 글자 수 하드컷 줄바꿈

합쳐진 텍스트에 대해 약 15~16자 기준으로 기계적으로 줄바꿈을 삽입한다.
이때 **단어 경계(공백)를 고려하지 않고** 글자 수만 세어 자르기 때문에
`"가즈아"` `"해"` 같은 부자연스러운 줄넘김이 발생한다.

---

## 진단 절차

Claude Code가 아래 순서대로 코드를 추적하여 버그 위치를 특정하라.

### Step 1: lines 배열이 합쳐지는 지점 찾기

```bash
# lines 배열을 join하거나 " ".join하는 코드 찾기
grep -rn "\.join(" ai_worker/pipeline/scene_director.py ai_worker/renderer/ --include="*.py"
grep -rn "join(.*lines" ai_worker/ --include="*.py"
grep -rn "\" \".join" ai_worker/ --include="*.py"
```

**의심 지점:**
- `ai_worker/pipeline/scene_director.py` — ScriptData의 body[i].lines를 Scene.text_lines로 변환하는 곳
- `ai_worker/renderer/subtitle.py` — Scene.text_lines를 ASS 자막으로 변환하는 곳
- `ai_worker/renderer/layout.py` — Scene.text_lines를 이미지 위에 그리는 곳

### Step 2: 글자 수 기준 줄바꿈 로직 찾기

```bash
# max_chars, char_limit, wrap, split 관련 코드 찾기
grep -rn "max_char\|char_limit\|text_wrap\|textwrap\|split_text\|break_line\|line_break\|줄바꿈\|wrap_text" ai_worker/ --include="*.py"

# 숫자 15 또는 16 근처의 하드코딩 찾기
grep -rn "\b1[45678]\b" ai_worker/renderer/ --include="*.py" | grep -i "char\|len\|max\|width\|wrap\|limit"

# layout.json에서 max_chars 설정 찾기
grep -rn "max_char" config/layout.json config/layout*.json
```

**의심 지점:**
- `config/layout.json`의 `max_chars` 필드
- `ai_worker/renderer/subtitle.py`의 줄바꿈 함수
- `ai_worker/renderer/layout.py`의 텍스트 렌더링 함수

### Step 3: Scene.text_lines 가 어떻게 전달되는지 추적

```bash
# text_lines 필드 사용 추적
grep -rn "text_lines" ai_worker/ --include="*.py"

# Scene 클래스 정의 찾기
grep -rn "class Scene" ai_worker/ --include="*.py"
grep -rn "Scene(" ai_worker/ --include="*.py"
```

---

## 수정 방안

### 원칙

```
1. 편집실에서 사용자가 나눈 줄바꿈(lines 배열의 각 원소)은 절대 합치지 않는다.
2. 각 line 내에서 글자 수 초과 시 줄바꿈이 필요하면 단어 단위(공백 기준)로 자른다.
3. hook, closer 같은 단일 문자열도 단어 단위로 줄바꿈한다.
```

### 수정 1: lines 배열을 합치는 코드 제거

**scene_director.py** 또는 데이터 변환 코드에서:

```python
# ❌ 현재 (추정) — lines를 합쳐서 단일 문자열로 만듦
text = " ".join(segment["lines"])

# ✅ 수정 — lines 배열을 그대로 유지
text_lines = segment["lines"]  # ["저체중", "영유아용 특수 분유에 대해"]
```

Scene 객체에 `text_lines: list[str]`로 전달되어야 한다.
각 원소가 화면의 한 줄에 대응한다.

### 수정 2: 단어 단위 줄바꿈 함수

기존의 글자 수 하드컷을 **단어 단위(공백 기준) 줄바꿈**으로 교체한다.

```python
def wrap_text_by_words(text: str, max_chars: int) -> list[str]:
    """한 줄이 max_chars를 초과하면 공백 기준으로 줄바꿈.
    
    규칙:
    1. max_chars 이하면 그대로 반환
    2. 초과하면 마지막으로 max_chars 안에 들어오는 공백 위치에서 자름
    3. 공백이 없는 긴 단어는 max_chars에서 강제로 자름 (한글 특성상 드묾)
    """
    if len(text) <= max_chars:
        return [text]
    
    lines = []
    remaining = text
    
    while remaining:
        if len(remaining) <= max_chars:
            lines.append(remaining)
            break
        
        # max_chars 범위 내에서 마지막 공백 찾기
        cut_pos = remaining[:max_chars].rfind(" ")
        
        if cut_pos == -1:
            # 공백 없음 — 강제 컷 (거의 발생하지 않음)
            cut_pos = max_chars
        
        lines.append(remaining[:cut_pos].rstrip())
        remaining = remaining[cut_pos:].lstrip()
    
    return lines
```

### 수정 3: 전체 줄바꿈 파이프라인

Scene의 text_lines 각 원소에 대해 개별적으로 wrap을 적용:

```python
def prepare_display_lines(text_lines: list[str], max_chars: int) -> list[str]:
    """편집실에서 나눈 줄바꿈을 유지하면서, 각 줄 내에서만 추가 줄바꿈.
    
    입력: ["저체중", "영유아용 특수 분유에 대해"]
    출력: ["저체중", "영유아용 특수 분유에 대해"]  (둘 다 max_chars 이하이므로 그대로)
    
    입력: ["매점매석 씨바꺼공정이 좆팡 가즈아"]  (17자, max_chars=15)
    출력: ["매점매석 씨바꺼공정이", "좆팡 가즈아"]  (공백 기준 분할)
    """
    result = []
    for line in text_lines:
        result.extend(wrap_text_by_words(line, max_chars))
    return result
```

### 수정 전후 비교

```
수정 전:
  입력: lines=["저체중", "영유아용 특수 분유에 대해"]
  처리: join → "저체중 영유아용 특수 분유에 대해" → 16자 하드컷
  출력: ["저체중 영유아용 특수분유에 대", "해"]  ❌

수정 후:
  입력: lines=["저체중", "영유아용 특수 분유에 대해"]
  처리: 각 줄 개별 wrap → "저체중"(3자 OK), "영유아용 특수 분유에 대해"(13자 OK)
  출력: ["저체중", "영유아용 특수 분유에 대해"]  ✅

수정 전:
  입력: hook="쿠팡이 베이비밀크 판매가격을 올렸나?" (단일 문자열)
  처리: 15자 하드컷
  출력: ["쿠팡이 베이비밀크 판매가격을", "올렸나?"]  ❌

수정 후:
  입력: hook="쿠팡이 베이비밀크 판매가격을 올렸나?" (단일 문자열)
  처리: wrap_text_by_words(text, 15) → 공백 기준 분할
  출력: ["쿠팡이 베이비밀크", "판매가격을 올렸나?"]  ✅

수정 전:
  입력: lines=["매점매석 씨바꺼공정이 좆팡 가즈아"] (17자)
  처리: 15자 하드컷
  출력: ["매점매석 씨바꺼공정이 좆팡 가", "즈아"]  ❌

수정 후:
  입력: lines=["매점매석 씨바꺼공정이 좆팡 가즈아"] (17자)
  처리: wrap_text_by_words → rfind(" ") at position 12
  출력: ["매점매석 씨바꺼공정이", "좆팡 가즈아"]  ✅
```

---

## 수정 대상 파일 (예상)

진단 후 정확한 위치가 확인되면 아래 파일을 수정:

| 파일 | 수정 내용 |
|---|---|
| `ai_worker/pipeline/scene_director.py` | body[i].lines를 join하지 않고 그대로 Scene.text_lines에 전달 |
| `ai_worker/renderer/subtitle.py` | 글자 수 하드컷 → `wrap_text_by_words()` 교체 |
| `ai_worker/renderer/layout.py` | 글자 수 하드컷 → `wrap_text_by_words()` 교체 |
| `config/layout.json` | `max_chars` 값 확인 (변경 불필요할 수 있음) |

### hook / closer 처리

hook과 closer는 단일 문자열이므로 `[hook]` 리스트로 감싼 뒤 동일 로직 적용:

```python
# hook
intro_lines = prepare_display_lines([script_data.hook], max_chars)

# body — lines 배열 그대로
for segment in script_data.body:
    body_lines = prepare_display_lines(segment["lines"], max_chars)

# closer
outro_lines = prepare_display_lines([script_data.closer], max_chars)
```

---

## 검증

수정 후 위 재현 데이터로 테스트:

```python
def test_line_breaks():
    max_chars = 15

    # Case 1: hook
    result = wrap_text_by_words("쿠팡이 베이비밀크 판매가격을 올렸나?", max_chars)
    assert result == ["쿠팡이 베이비밀크", "판매가격을 올렸나?"], f"Got: {result}"

    # Case 2: 의도적 줄바꿈 유지
    result = prepare_display_lines(["저체중", "영유아용 특수 분유에 대해"], max_chars)
    assert result == ["저체중", "영유아용 특수 분유에 대해"], f"Got: {result}"

    # Case 3: 의도적 줄바꿈 유지
    result = prepare_display_lines(["쿠팡은 이 가격에 팔다가", "수입사 남은 재고 물량을 아도 침"], max_chars)
    assert result == ["쿠팡은 이 가격에 팔다가", "수입사 남은 재고", "물량을 아도 침"], f"Got: {result}"

    # Case 4: 단어 단위 줄바꿈
    result = wrap_text_by_words("매점매석 씨바꺼공정이 좆팡 가즈아", max_chars)
    assert result == ["매점매석 씨바꺼공정이", "좆팡 가즈아"], f"Got: {result}"

    print("✅ 모든 줄바꿈 테스트 통과")

test_line_breaks()
```

---

## 실행 지시

```
이 문서를 읽고 아래 순서로 진행하라:

1. 진단 — Step 1~3의 grep 명령으로 버그 위치 특정
2. lines 배열이 join되는 코드를 찾아 제거
3. 글자 수 하드컷 줄바꿈 함수를 wrap_text_by_words()로 교체
4. hook, closer도 동일 로직 적용
5. 검증 코드 실행하여 통과 확인
6. 실제 렌더링 테스트 (가능하면)
```
