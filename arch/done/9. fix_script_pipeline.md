# 작업 지시서: LLM 대본 → 영상 파이프라인 4가지 버그 수정

## 배경

유튜브 쇼츠 자동 생성 파이프라인에서 LLM이 생성한 대본(JSON)이 영상에 렌더링될 때 4가지 문제가 발생하고 있다. 이 문서는 **프롬프트 수정**, **데이터 모델 수정**, **파싱 로직 수정**, **렌더링 로직 수정**을 모두 포함한다.

---

## 문제 요약

| # | 문제 | 원인 | 수정 대상 |
|---|------|------|-----------|
| 1 | LLM이 2줄로 나눈 `lines` 배열이 영상에서 1줄로 합쳐져 강제 줄바꿈 발생 | Scene 변환 또는 렌더링에서 `lines`를 공백으로 join하거나 재래핑 | 코드 (layout.py, scene 변환 로직) |
| 2 | LLM이 21자 넘는 긴 문장을 1줄로 줌 → 화면에서 단어 중간이 잘림 | LLM이 글자 수를 정확히 세지 못함 | 프롬프트 (client.py) |
| 3 | `"..."` 같은 문장부호만 단독으로 `lines` 배열의 한 줄이 됨 | LLM이 기호를 독립 문장으로 취급 | 프롬프트 (client.py) |
| 4 | 베스트 댓글과 본문이 동일한 구조 → 화면 전환/UI 차별 불가 | JSON 스키마에 type 구분 없음 | 프롬프트 + 모델 + 파싱 + 렌더링 전체 |

---

## 수정 1: 프롬프트 전면 개편 (`ai_worker/llm/client.py`)

### `_SCRIPT_PROMPT_V2` 를 아래 내용으로 **전체 교체**한다.

```python
_SCRIPT_PROMPT_V2 = """\
당신은 유튜브 쇼츠 대본 작가입니다.
아래 입력을 읽고, 반드시 JSON 형식으로만 응답하세요. 다른 텍스트는 절대 포함하지 마세요.

## 입력
- 제목: {title}
- 본문: {body}
- 베스트 댓글: {comments}

## 출력 형식 (JSON)
{{
  "hook": "시청자가 스크롤을 멈출 한 줄 (15자 이내, 의문형 또는 감탄형)",
  "body": [
    {{
      "type": "body",
      "line_count": 2,
      "lines": ["의미 단위로 자연스럽게 끊은 앞부분", "이어지는 자연스러운 뒷부분"]
    }},
    {{
      "type": "body",
      "line_count": 1,
      "lines": ["단어 중간에 끊기지 않은 한 줄"]
    }},
    {{
      "type": "comment",
      "author": "닉네임",
      "line_count": 2,
      "lines": ["베댓의 내용만 호흡에 맞춰", "자연스럽게 분할하여 작성"]
    }}
  ],
  "closer": "여러분들의 생각은 어떤가요?",
  "title_suggestion": "원문 제목 그대로 기입 (수정 절대 금지)",
  "tags": ["태그1", "태그2", "태그3"],
  "mood": "daily"
}}

## 규칙
1. 블록 타입 분리 (필수): 본문 내용은 `"type": "body"`로 작성하고, 베스트 댓글은 화면 연출이 달라지므로 반드시 `"type": "comment"`로 작성하세요.
2. 댓글 분리 규정: `type`이 `comment`일 경우, 작성자의 닉네임은 `"author"` 필드에 분리해 넣고, `"lines"` 배열에는 닉네임을 제외한 순수 '댓글 내용'만 넣으세요.
3. 자막 분할 및 가독성 (가장 중요):
   - `lines` 배열의 각 항목은 화면에 출력될 '한 줄'의 자막입니다. 억지로 글자 수에 맞춰 단어 중간(예: '만나/고')에서 자르지 마세요.
   - 반드시 사람이 읽기 편한 15~20자 내외의 **'의미 단위(어절, 호흡)'**로 자연스럽게 나누세요. (예: 18자 1줄, 12자 1줄 방식)
   - 한 줄이 20자를 넘어가면 반드시 의미 단위로 분할하여 line_count를 늘리세요.
   - 쉼표(,), 줄임표(...), 마침표(.) 등 문장 부호만 단독으로 `lines` 배열의 한 줄로 만드는 것을 엄격히 금지합니다.
   - 빈 문자열("")을 넣는 것을 절대 금지합니다.
   - `line_count`의 숫자와 `lines` 배열 안의 실제 문장 개수는 반드시 일치해야 합니다.
4. 분량 및 문맥 유지: 원문의 길이에 비례하여 `body` 배열 항목 수를 동적으로 확장해 서사가 누락되지 않게 하세요.
5. 베스트 댓글 최대 반영: 주어진 베스트 댓글(최대 5개)은 대본 후반부에 모두 `comment` 타입으로 포함하세요.
6. 어조 및 시점: 원문 글쓴이의 1인칭 시점을 유지하되, 시청자에게 말하듯 친근한 구어체(~했다, ~인데, ~음)를 쓰세요. 진지하거나 슬픈 사연에 'ㅋㅋ' 같은 가벼운 표현이나 억지스러운 자극을 더하는 것은 엄격히 금지합니다.
7. 감정 분류: 글의 분위기를 (touching, humor, anger, sadness, horror, info, controversy, daily, shock) 중 가장 적합한 하나로 골라 `mood` 필드에 기입하세요.
8. 기타: 한국어만 사용하며, 없는 사실을 지어내거나 왜곡하지 마세요. 제목은 `title_suggestion`에 토씨 하나 바꾸지 말고 그대로 기입하세요.
"""
```

### 핵심 변경 포인트
- `"type"` 필드 추가: `"body"` 또는 `"comment"`
- `"author"` 필드 추가: `comment` 타입 전용, 닉네임 분리
- 글자 수 기준 `21자` → `15~20자 내외 의미 단위` 로 변경 (LLM이 글자 수를 못 세므로)
- 문장부호 단독 줄 금지 규칙 명시
- 단어 중간 잘림 금지 규칙 강화

---

## 수정 2: 데이터 모델 업데이트 (`db/models.py`)

### `ScriptData`의 `body` 내부 항목 구조 변경

기존 body 항목:
```python
{"line_count": 2, "lines": ["앞부분", "뒷부분"]}
```

신규 body 항목 (하위호환 유지):
```python
# 본문
{"type": "body", "line_count": 2, "lines": ["앞부분", "뒷부분"]}

# 댓글
{"type": "comment", "author": "ㅇㅇ", "line_count": 2, "lines": ["댓글 내용 앞", "댓글 내용 뒤"]}
```

### 작업 내용

`ScriptData` 클래스에 아래 사항을 반영한다:

1. `body` 필드의 각 dict 항목이 `type`(str, 기본값 `"body"`)과 `author`(Optional[str], 기본값 None) 필드를 가질 수 있도록 한다.
2. `to_plain_text()` 메서드에서 comment 타입일 때 author를 포함하여 텍스트 생성하도록 수정.
3. **하위 호환**: `type` 필드가 없는 기존 데이터도 정상 동작해야 한다 (기본값 `"body"` 처리).

---

## 수정 3: JSON 파싱 로직 업데이트 (`ai_worker/llm/client.py`)

### `_parse_script_json()` 함수의 body 정규화 부분 수정

현재 코드:
```python
for item in body_raw:
    if isinstance(item, str):
        body.append({"line_count": 1, "lines": [item]})
    elif isinstance(item, dict):
        lines = item.get("lines", [])
        body.append({"line_count": len(lines), "lines": lines})
```

수정 후:
```python
for item in body_raw:
    if isinstance(item, str):
        body.append({"type": "body", "line_count": 1, "lines": [item]})
    elif isinstance(item, dict):
        lines = item.get("lines", [])
        block_type = item.get("type", "body")  # 하위 호환: 없으면 "body"
        author = item.get("author")             # comment일 때만 존재
        entry = {
            "type": block_type,
            "line_count": len(lines),
            "lines": lines,
        }
        if author:
            entry["author"] = author
        body.append(entry)
```

### `_extract_fields_regex()` 함수도 동일하게 수정
regex 폴백에서도 `type`, `author` 필드를 추출하도록 업데이트한다.

---

## 수정 4: 렌더링 로직 — lines 배열 올바른 처리 (`ai_worker/renderer/layout.py`)

### 문제 [1] 핵심: `render_layout_video()`의 Step 1에서 lines가 보존되고 있으나, 실제 렌더링 경로(render_layout_video_from_scenes)에서 SceneDecision으로 변환될 때 lines가 공백 join 될 수 있음

#### 4-1. `render_layout_video()` Step 1 확인 및 보강

현재 코드에서 `body_text = " ".join(pre_split_lines)` 는 TTS용 텍스트이고, `sent["lines"] = pre_split_lines`로 렌더링용 lines는 별도 보존하고 있다. 이 부분은 정상이나, **comment 타입을 전달하도록 수정**이 필요하다:

```python
# Step 1: 문장 구조화 수정
for body_item in script.body:
    if isinstance(body_item, dict):
        pre_split_lines: list[str] | None = body_item.get("lines")
        body_text = " ".join(pre_split_lines) if pre_split_lines else ""
        block_type = body_item.get("type", "body")
        author = body_item.get("author")
    else:
        body_text = str(body_item)
        pre_split_lines = None
        block_type = "body"
        author = None

    is_quote = block_type == "comment" or any(
        q in body_text for q in ('"', "'", "\u2018", "\u2019", "\u201c", "\u201d")
    )
    sent: dict = {
        "text": body_text,
        "section": "comment" if is_quote else "body",
        "block_type": block_type,  # 신규: "body" 또는 "comment"
    }
    if author:
        sent["author"] = author
    if pre_split_lines:
        sent["lines"] = pre_split_lines
    sentences.append(sent)
```

#### 4-2. `_render_text_only_frame()` — comment 타입 시 다른 UI 렌더링

comment 타입일 때는 다른 색상/스타일로 렌더링하여 본문과 시각적으로 구분한다.

```python
def _render_text_only_frame(
    base_frame: Image.Image,
    text_history: list[dict],   # [{"lines": list[str], "is_new": bool, "block_type": str, "author": str|None}]
    layout: dict,
    font_dir: Path,
    out_path: Path,
) -> Path:
```

text_history 각 entry에 `block_type`과 `author` 정보를 전달해야 한다.

**comment 렌더링 차별화 예시:**
- 닉네임(author)을 작은 폰트 + 회색으로 줄 위에 표시
- 댓글 내용은 다른 색상(예: 노란색 또는 청록색)으로 표시
- 또는 comment 전용 배경 박스(반투명)를 그려서 시각 구분

#### 4-3. Step 8 프레임 생성에서 block_type 전달

layout.py의 Step 8에서 text_only_history에 항목 추가 시:

```python
# 기존
text_only_history.append({"lines": new_lines, "is_new": True})

# 수정 후
sent = sentences[sent_idx] if sent_idx is not None else {}
text_only_history.append({
    "lines": new_lines,
    "is_new": True,
    "block_type": sent.get("block_type", "body"),
    "author": sent.get("author"),
})
```

---

## 수정 5: SceneDecision 변환 경로 (`_scenes_to_plan_and_sentences`)

`render_layout_video_from_scenes()` 경로를 사용하는 경우, SceneDecision에서 sentences로 변환할 때도 `block_type`과 `author`를 보존해야 한다.

**scene_director.py** (또는 content_processor.py)에서 SceneDecision을 생성할 때:
- LLM body 항목의 `type`이 `"comment"`이면 SceneDecision에도 해당 정보를 전달
- SceneDecision 클래스에 `block_type: str = "body"`, `author: str | None = None` 필드 추가 검토

`_scenes_to_plan_and_sentences()`에서:
```python
sentences.append({
    "text": text,
    "section": "body",
    "audio": audio,
    "voice_override": scene.voice_override,
    "block_type": getattr(scene, "block_type", "body"),   # 신규
    "author": getattr(scene, "author", None),              # 신규
})
```

---

## 수정 6: subtitle.py 댓글 판별 로직 개선 (선택적)

현재 `_is_comment_sentence()`는 따옴표 기반 휴리스틱이다. 이제 구조적으로 `block_type`을 전달할 수 있으므로, 가능하다면 `build_ass()` 호출 시 각 문장의 타입 정보를 함께 전달하여 정확한 스타일 분기를 하도록 개선한다.

---

## 수정 우선순위

1. **프롬프트 교체** (client.py `_SCRIPT_PROMPT_V2`) — 문제 [2][3][4] 해결의 근본
2. **파싱 로직** (client.py `_parse_script_json`) — 새 필드 수용
3. **데이터 모델** (db/models.py `ScriptData`) — 새 필드 저장
4. **렌더링** (layout.py) — 문제 [1][4] 해결, comment UI 차별화
5. **SceneDecision 변환** — from_scenes 경로 호환

---

## 테스트 체크리스트

- [ ] LLM 응답에서 `"type": "comment"` 블록이 정상 파싱되는지
- [ ] LLM 응답에서 `"type"` 없는 기존 형식도 하위호환되는지
- [ ] `lines: ["올해 37살 된 여자인데", "(만으로는 36살)"]` → 영상에서 2줄로 표시되는지
- [ ] 20자 넘는 문장이 LLM 단에서 사전 분할되어 오는지
- [ ] `"..."` 같은 부호만 단독으로 한 줄이 되지 않는지
- [ ] comment 블록이 본문과 시각적으로 구분되는지 (색상/닉네임 표시)
- [ ] TTS에서 comment의 author(닉네임)는 읽지 않고, 댓글 내용만 읽는지
- [ ] `title_suggestion`이 원문 그대로 유지되는지

---

## 참고: 기대하는 LLM 출력 예시

```json
{
  "hook": "30대 중반 소개팅의 현실?",
  "body": [
    {
      "type": "body",
      "line_count": 2,
      "lines": ["올해 37살 된 여자인데", "(만으로는 36살)"]
    },
    {
      "type": "body",
      "line_count": 2,
      "lines": ["최근 소개팅에서 만난 사람과", "만나고 있습니다"]
    },
    {
      "type": "body",
      "line_count": 2,
      "lines": ["100% 마음에 들지는 않지만", "나쁘지 않아서 만나고 있는데"]
    },
    {
      "type": "body",
      "line_count": 2,
      "lines": ["이 사람이다 싶은건", "아직 없는 것 같아요"]
    },
    {
      "type": "body",
      "line_count": 1,
      "lines": ["다들 이렇게 결혼하신건가요?"]
    },
    {
      "type": "comment",
      "author": "ㅇㅇ",
      "line_count": 3,
      "lines": ["30대 후반이면 괜찮은 사람은", "이미 짝 찾아 가정을 이루었을", "가능성이 크다는 걸 말씀드리고 싶네요"]
    },
    {
      "type": "comment",
      "author": "ㅇㅇ",
      "line_count": 2,
      "lines": ["그 사람은 님이", "이 사람이다 싶어 만날까요"]
    }
  ],
  "closer": "여러분들의 생각은 어떤가요?",
  "title_suggestion": "30대 중반 소개팅... 이게 맞아요?",
  "tags": ["소개팅", "연애", "결혼"],
  "mood": "daily"
}
```
